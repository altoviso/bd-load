<?xml version='1.0'?>
<!DOCTYPE article[
<!ENTITY mdash "–">
<!ENTITY bc "browser&#x2194;compute">
<!ENTITY implies "⇒">
<!ENTITY deps '<code xmlns="http://docbook.org/ns/docbook">dependencies</code>'>

]>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0">
    <info>
        <title>bdLoad</title>
        <subtitle>Tutorial and Reference Manual</subtitle>
        <copyright>
            <year>2011</year>
            <holder>Rawld Gill</holder>
        </copyright><pubdate>This document was generated <?dbtimestamp format="Y-m-d H:M:S"?>.</pubdate>
        <author>
            <personname>
                <firstname> Rawld </firstname>
                <surname> Gill </surname>
            </personname>
            <affiliation>
                <jobtitle> Chief Engineer </jobtitle>
                <orgname> ALTOVISO LLC </orgname>
            </affiliation>
            <address>
                <street>3478 Buskirk Avenue, Suite 1000</street>
                <city>
                    Pleasant Hill
                </city>
                <postcode>
                    94523
                </postcode>
                <country>
                    USA
                </country>
            </address>
            <email> rgill@altoviso.com </email>
        </author>
        <abstract>
            <para>bdLoad is a <link xlink:href="http://www.commonjs.org/">CommonJS</link>
                <link xlink:href="http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition"
                    >Modules/AsynchronousDefinition</link> compliant script injection loader for use
                loading browser-based JavaScript applications. Its design places a high value on
                minimum size and maximum run-time and build-time configurability. This tutorial is
                intended for the loader consumer and describes how to use all loader features. The
                tutorial also includes additional information to help build the reader's intuition
                and mental model of how Modules/AsynchronousDefinition loaders work in general and
                the backdraft loader works in particular.</para>
        </abstract>
    </info>
    <sect1>
        <title>Overview</title>
        <para>The use of JavaScript in the browser has advanced to the point where applications that
            include tens of thousands of lines of code are frequently encountered. In order to
            control the complexity&mdash;and, therefore, cost&mdash;of such applications, a
            carefully designed system for dividing large code stacks into modules and then
            reassembling these modules in the browser must be employed. This is the job of a loader.
            Since the loader's job is to load code, it is usually the first code executed in an
            application. Because of this special status, loaders may define a few other types of
            machinery:<itemizedlist>
                <listitem>
                    <para>Configuration control</para>
                </listitem>
                <listitem>
                    <para>Application bootstrap</para>
                </listitem>
                 <listitem>
                    <para>DOM content loaded detection</para>
                </listitem>              <listitem>
                    <para>Global namespace management</para>
                </listitem>
                
                 <listitem>
                    <para>Error detection and recovery</para>
                </listitem>

                <listitem>
                    <para>Debugging machinery</para>
                </listitem>
            </itemizedlist></para>
        <para>Loaders are difficult to get right. Most of the problem is rooted in the desire to add
            features, yet keep the loader small and unobtrusive. After all, once the application is
            loaded, the loader basically becomes a chunk of dead code that doesn't do anything.
            Clearly to pay for downloading 10K onto an iphone just to load the real application is a
            nonstarter. So there are lots of tradeoffs and some disagreement among loader developers
            about which are the right tradeoffs to take. The backdraft loader was designed with the
            following values:<glosslist>
                <glossentry>
                    <glossterm>Loader size is unimportant during development; it is often critically
                        important for released applications.</glossterm>
                    <glossdef>
                        <para>During development, the http server is usually on the developers
                            machine and the size of the loader has no effect on load times;
                            conversely, when deploying to certain client targets (e.g., phones),
                            size may be the most important feature when selecting a loader. </para>
                    </glossdef>
                </glossentry>
                <glossentry>
                    <glossterm>The loader must be highly configurable, both at run-time and
                        build-time.</glossterm>
                    <glossdef>
                        <para>Since the development and release requirements may be quite different
                            as indicated above, the loader must be highly configurable. Also,
                            different types of applications require different loader features.
                            Programmers are highly resistive to paying for features they don't
                            use&mdash;particularly with respect to bandwidth costs for released
                            applications.</para>
                    </glossdef>
                </glossentry>
                <glossentry>
                    <glossterm>The loader must be able to operate without its injection machinery
                        for released applications.</glossterm>
                    <glossdef>
                        <para>The loader must support constructing a release that precaches all
                            resources in a single resource and then simply uses the loader to
                            evaluate those resources in the correct order. In this scenario, the
                            loader injection machinery must be removable.</para>
                    </glossdef>
                </glossentry>
            </glosslist></para></sect1>
    <sect1>
        <title>Core Api</title>
        <sect2><title>require and define</title>
        <para>The core loader API is simple, containing but two functions: <code>require</code> and
                    <code>define</code>. Both of these functions reside in the global namespace and
                are available after the loader itself has been defined.</para>
      
        <para>The global function <code>require</code> causes JavaScript resources to be evaluated;
                it has the following signature:</para>
        <funcsynopsis>
            <funcprototype>
                    <funcdef>function <function>require</function></funcdef>
                    <paramdef>[optional]object <parameter>configuration</parameter></paramdef>
                    <paramdef>array of string <parameter>dependencies</parameter></paramdef>
                    <paramdef>[optional]function <parameter>callback</parameter></paramdef>
                </funcprototype>
        </funcsynopsis>
        <para>If <code>configuration</code> is provided, then the loader's configuration is
                adjusted; I'll discuss configuration in <xref linkend="boot"/>. Next, the JavaScript
                resources implied by the strings contained in &deps; are evaluated, and finally
                    <code>callback</code> (if any) is applied to the results of those evaluations.
                The JavaScript resources are termed "modules", and the strings contained in the
                dependency vector are termed "module identifiers". <code>require</code> returns
                itself so that chaining several <code>require</code> applications is easy. Finally,
                    <code>require</code> is an asynchronous function, and there is no guarantee that
                all of the prescribed processing has completed prior to it's return. </para>
        <para>In order to fully understand how all of this works, we must understand...
            <itemizedlist>
                    <listitem>
                        <para>how a particular module identifier given in &deps; is resolved into
                            some chunk of JavaScript code</para>
                    </listitem>
                    <listitem>
                        <para>how a particular chunk of JavaScript code is evaluated and returns a
                            value to the loader which may then be passed to
                            <code>callback</code></para>
                    </listitem>
                </itemizedlist></para>
            <para>Let's answer the second question first.</para>
            <para>When the loader is requested to evaluate a JavaScript resource, it retrieves the
            chuck of JavaScript that embodies the resource and causes the evaluation of that chunk
            in the execution environment. The actual methods used for retrieval and evaluation vary
            depending upon both the execution environment and the loader configuration. From now on,
            I'll use the term "load" to indicate the aggregate of the retrieval and evaluation
            process. In the browser environment, JavaScript resources are usually loaded by
            attaching a <code>script</code> element to the <code>head</code> element with its
                <code>src</code> attribute pointing to the resource. I say "usually" because the
            backdraft loader allows JavaScript resources to be precached.<footnote>
                <para>This capability is used by the backdraft build system which bundles several
                    JavaScript resources into a single resource that is loaded with a single http
                    transaction, thereby improving the load performance (see <xref linkend="build"/></para>
            </footnote>
        </para>
        <para>In general, the loader has no control about what a script actually does; in some
                environments, the loader doesn't even have control over the order of execution of
                demanded scripts. Further, notice that since a script may be loaded by attaching a
                    <code>script</code> element to the document, the loader has no way of collecting
                a result from the script. Instead, the script must explicitly publish a result to
                the loader. This is the purpose of the second core function,
                <code>define</code>.</para>
        <para>The global function <code>define</code> publishes the value of a module to the loader;
                it has the following signature:</para>
        <funcsynopsis>
            <funcprototype>
                <funcdef>void <function>define</function></funcdef>
                <paramdef>[optional]string <parameter>moduleId</parameter></paramdef>
                <paramdef>[optional]array of string <parameter>dependencies</parameter></paramdef>
                <paramdef>any <parameter>factory</parameter></paramdef>
            </funcprototype>
        </funcsynopsis>
        <para><code>define</code> causes the modules given by the module identifiers contained in
                &deps; to be evaluated and then associates the value implied by <code>factory</code>
                with the identifier given by <code>moduleId</code> and remembers the association. If
                    <code>factory</code> is a function, then the module value is computed by
                applying the function to the values of the modules implied by the dependency vector;
                otherwise, the module value is taken to be the value of <code>factory</code>
                directly. Just like <code>require</code>, <code>define</code> is asynchronous and
                returns immediately with no guarantee that all of the prescribed processing has
                completed prior to it's return. Finally, if <code>moduleId</code> is missing, then
                the loader derives <code>moduleId</code> from the module identifier in the
                dependency vector that caused the resource that contained the <code>define</code>
                application to be loaded. For example, if the code...
            <programlisting>
require(["arithmetic"]);
</programlisting></para>
        <para>...caused the loader to load a script containing the
            code...<programlisting>
define({
  add: function(x, y) { return x + y; },
  sub: function(x, y) { return x - y; }
});
</programlisting></para>
        <para>...then the loader can derive that the <code>define</code> application has the implied
                    <code>moduleId</code> of "arithmetic". In almost all cases,
                    <code>moduleId</code> should not be provided explicitly in a <code>define</code>
                application, but rather should be implied. I'll explain why later.</para>
        <para>We can now see how the loader becomes aware of module values:
            <itemizedlist>
                <listitem>
                    <para>the dependency vector in either a <code>require</code> or
                            <code>define</code> application demands modules</para>
                </listitem>
                <listitem>
                    <para><code>define</code> applications contained in those modules cause the
                        loader to associate a module value with a module identifier and remember the
                        association.</para>
                </listitem>
            </itemizedlist>The values passed to either the <code>callback</code> argument (in the
            case of <code>require</code>) or the <code>factory</code> argument (in the case of
                <code>define</code>, when <code>factory</code> is a function) are just module values
            previously associated with module identifiers. For
            example,<programlisting>
require(
  ["dijit/layout/TabContainer", "bd/widgets/stateButton"], 
  function(tabContainer, stateButton) {
    // do something with tabContainer and stateButton...
  }
);
</programlisting></para>
        <para>... and
            ...<programlisting>
define(
  ["dijit/layout/TabContainer", "bd/widgets/stateButton"],
  function(tabContainer, stateButton) {
    // do something with tabContainer and stateButton...
  }
);
</programlisting></para>
        <para>...both gain access to the values of the
                    <filename>dijit/layout/TabContainer</filename> and
                    <filename>bd/widgets/stateButton</filename> modules by the <emphasis role="italic">loader two-step</emphasis>:
            <itemizedlist>
                    <listitem>
                        <para>list the module identifier in the dependency vector</para>
                    </listitem>
                    <listitem>
                        <para>provide a parameter in the callback function definition (in the case
                            of <code>require</code>) or the factory function definition (in the case
                            of <code>define</code>, when <code>factory</code> is a function) that
                            receives the value of the module listed in the dependency vector</para>
                    </listitem>
                </itemizedlist>The items in the dependency vector are matched to parameters in the
                callback/factory function by position. The parameter names are not significant to
                the loader. For example, this is perfectly legal, if not ridiculous,
                code:<programlisting>
require(
  ["dijit/layout/TabContainer"],
  function(supercalifragilisticexpialidocious) {
    // do something with tabContainer...
  }
);
</programlisting>Of
                course this all assumes that any module identifier specified in a dependency vector
                always results in loading a script that includes a <code>define</code> application.
                But, what if you just want to download and evaluate a chunk of code that doesn't
                define a module? That's OK too. The loader machinery will detect when the resource
                has been evaluated and notice that a module was not defined. In this case the loader
                simply notes that the module isn't really a module, but just a chunk of code. If you
                happen to demand the value for such a "nonmodule", the loader will provide
                    <code>undefined</code>.</para>
        <para>There's one last detail about retrieving module values we need to cover. What if some
            random chunk of code existing somewhere in your application wants a module, say
                <filename>bd/widgets/stateButton</filename>, and further, that chunk of code is not
            part of a callback or factory function or didn't include
                <filename>bd/widgets/stateButton</filename> in the dependency vector, yet that same
            random chunk of code happens to know that <filename>bd/widgets/stateButton</filename>
            has been defined? To solve this problem, the loader includes a way to directly retrieve
            module values from the module namespace maintained by the loader with the alternate
                <code>require</code> signature:</para>
        <funcsynopsis>
            <funcprototype>
                <funcdef>any <function>require</function></funcdef>
                <paramdef>string <parameter>moduleId</parameter></paramdef>
            </funcprototype>
        </funcsynopsis>
                    <para>When <code>require</code> is provided a single string argument, that
                argument is interpreted as a module identifier and <code>require</code> returns the
                    <emphasis role="italic">current</emphasis> value associated with that module
                identifier. If the given module has not been defined, then <code>require</code>
                returns undefined. If the given module has not be loaded, it will not load the
                module. </para>
        <para>My advice: don't use this feature; it just opens up a potential program error in your
            application when the module you think is defined actually is not. And don't use
                <code>supercalifragilisticexpialidocious</code> for a variable name.</para>
        <para>Enough nonsense; the important point is this: the space of module identifiers forms a
            namespace managed by the loader, and this namespace can be used by application authors
            to manage the global namespace. This idea is sometimes misconstrued: it is wrong to say
            the loader "doesn't allow global variables." The loader has no control over such
            matters. It is up to individual programmers to determine whether or not to pollute the
            global namespace. The loader merely gives machinery that programmers may use to store
            their top-level names.</para></sect2>
        <sect2><title>Relative Module Identifiers</title>
        <para>So far, we've seen module identifiers appear in two locations:
            <itemizedlist>
                <listitem>
                    <para>in the <code>moduleId</code> argument to the <code>define</code>
                        function</para>
                </listitem>
                <listitem>
                    <para>in the &deps; argument to both the <code>require</code> and
                            <code>define</code> functions</para>
                </listitem>
            </itemizedlist>
        </para>
        <para>Module identifiers given in the dependencies vector in a <code>define</code> function
                application can be <emphasis role="italic">relative</emphasis> identifiers. For
                example, consider the <code>define</code>
                application...<programlisting>
define(
  "myPackage/myModule",
  ["myPackage/utils", "myPackage/myModule/mySubModule"],
  function(utils, submodule) {
    // do something spectacular
  }
);
</programlisting></para>
        <para>When the loader is processing this <code>define</code> application, it understands it
                is defining the module <filename>myPackage/myModule</filename>; this is termed the
                "reference module" with respect to this <code>define</code> application. The loader
                allows module identifiers to be relative to the reference module. Therefore, you can
                rewrite the define application above as
                follows:<programlisting>
define(
  "myPackage/myModule", 
  ["./utils", "./myModule/mySubModule"], 
  function(utils, submodule) {
  // do something spectacular
  }
);
</programlisting></para>
        <para>The relative module identifiers "./utils" and "./myModule/mySubModule" are relative to
                the reference module <filename>myPackage/myModule</filename>, where "./" &implies;
                "myPackage/". You can <emphasis role="italic">loosely</emphasis> think of "." as the
                parent "directory" of the current module. So we have</para>
        <para>"./utils" &implies; "myPackage/utils</para>
        <para>and</para>
        <para>"./myModule/mySubmodule" &implies; "myPackage/myModule/mySubmodule</para>
        <para>Recall that the <code>moduleId</code> argument can be implied. So, we can
                write...<programlisting>
require("myPackage/myModule");
</programlisting>...and
                then, in the JavaScript resource implied by myPackage/myModule,
                write...<programlisting>
define(
  ["./utils", "./myModule/mySubModule"],
  function(utils, submodule) {
    // do something spectacular
  }
);
</programlisting></para>
        <para>Once again, ./utils and ./myModule/mySubModule are relative to the reference module,
                which in this case is implied. This is the best practice for defining
                modules:
            <itemizedlist>
                <listitem>
                    <para>The module name should never be specified explicitly.</para>
                </listitem>
                <listitem>
                    <para>Any module identifiers that are members of the same package as the module
                        being defined should be specified as relative identifiers.</para>
                </listitem>
            </itemizedlist>
        </para>
        <para>If these rules are followed, then the loader can provide a very powerful feature to
                package consumers: <emphasis role="italic">the top-level namespace can be fully
                    controlled to load two different packages with the same name and/or two
                    different versions of the same package</emphasis>. We'll explore this in detail
                in <xref linkend="nameClashes"/>. </para>
        <para>Let's finish up one last detail about reference modules. Suppose I have a factory
                function that, depending on program flow, needs to conditionally require and execute
                some code. For
                example,<programlisting>
// this is the resource for the module "myApp/topLevelHandlers"

define(
  ["dojo"], 
  function(dojo) {
    dojo.connect(dojo.byId("debugButton"), "click" function() {
      require(
        ["myApp/perspectives/debug"], 
        function(perspective) { perspective.open(); }
      );
    });

    // etc.

  }
);
    </programlisting></para>
        <para>The factory function simply hooks up an event handler that loads some code <emphasis role="italic">if and when</emphasis> the user clicks a particular button. This
                code is perfectly legal code, but it can be better. Notice how the
                    <code>require</code> application uses a fully-qualified (that is, not relative)
                module identifier. But, since this code is in the
                    <filename>myApp/topLevelHandlers</filename> module, we ought to be able to write
                "./perspectives/debug" instead of "myApp/perspectives/debug". Unfortunately, the
                global require function doesn't know anything about reference modules. What we need
                is a way to remember the reference module for later use.</para>
        <para>You can get this effect by specifying the module identifier "require" in the
                dependency
                vector:<programlisting>// this is the resource for the module "myApp/topLevelHandlers"

define(["dojo", "require"], function(dojo, require) {
  dojo.connect("debugButton", "click" function() {
    require(
      ["./perspectives/debug"], 
      function(perspective) { perspective.open(); }
    );
  });

  // etc.
});
    </programlisting></para>
        <para>The require application is now executed on the lexical variable
            <code>require</code>--not the global <code>require</code> function. The loader arranges
            for this require to resolve module identifiers with respect to the reference module in
            which it was provided. This context-sensitive <code>require</code> function is termed a
            "context require". The resulting code now abides by the best practice of always using
            relative module identifiers when defining a module.</para>
        </sect2>
        <sect2><title>Resolving Module Identifiers to URLs</title>
        <para>Let's now turn to the question of how the loader resolves a module identifier into a
                resource URL. Module identifiers look like file system paths, for example,
                    <filename>bd/widgets/stateButton</filename>. They are given by a sequence of
                names separated by forward-slashes. The names may be any legal JavaScript
                identifier, and, by convention, are camel-case.<footnote>
                    <para>In particular, the CommonJS <link xlink:href="http://wiki.commonjs.org/wiki/Modules/1.1">http://wiki.commonjs.org/wiki/Modules/1.1</link> specification requires
                        module names be composed of camel-case identifiers.</para>
                </footnote> Notice that since the loader maintains a namespace of module identifiers
                associated with module values, the loader effectively maintains a hierarchical
                namespace. The top-level names in this namespace (that is, the first name in any
                module identifier) are termed "package identifiers" by the loader. For example, the
                module identifier <filename>bd/widgets/stateButton</filename> indicates the package
                    <filename>bd</filename>, and it is correct to say
                    <filename>bd/widgets/stateButton</filename> indicates the
                    <filename>widgets/stateButton</filename> module in the <filename>bd</filename>
                package.</para>
        <para>The loader may be configured to be aware of zero or more packages. This begs the
                question, what if a particular module identifier indicates a package that does not
                exist in the loader configuration? In this case, the package is taken as the
                "default" package and you can imagine the prefix <filename>"default/"</filename> is implied.<footnote>
                    <para><filename>default</filename> is not actually defined inside the loader,
                        but rather is used as a device to give you a mental model of how the loader
                        works.</para>
                </footnote> Then there's the other oddity when the module identifier specifies only
                a package identifier. In this case, the module identifier is said to indicate the
                package "main module" and you can imagine the suffix "/main" is implied. Let's go
                through a few cases to make this clear:<itemizedlist>
                    <listitem>
                        <para>Given module identifier "X", and a package named "X" has not been
                            named in the configuration, the package identifier is implied to be
                            "default", and the fully qualified module identifier is
                            "default/X".</para>
                    </listitem>
                    <listitem>
                        <para>Given module identifier "X", and a package named "X" has been named in
                            the configuration, the package identifier is "X" and the fully qualified
                            module identifier is "X/main".</para>
                    </listitem>
                    <listitem>
                        <para>Given module identifier "X/Y", and a package named "X" has not been
                            named in the configuration, the package identifier is implied to be
                            "default", and the fully qualified module identifier is
                            "default/X/Y".</para>
                    </listitem>
                    <listitem>
                        <para>Given module identifier "X/Y", and a package named "X" has been named
                            in the configuration, the package identifier is "X" and the fully
                            qualified module identifier is "X/Y".</para>
                    </listitem>
                </itemizedlist>The take away is that a fully qualified module identifier always
                begins with a package identifier and always includes at least one module name within
                that package.</para>
        <para>When a configuration is given for a particular package, it includes the following
            configuration variables:<variablelist>
                <varlistentry>
                    <term>name</term>
                    <listitem>
                        <para>The package identifier</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>location</term>
                    <listitem>
                        <para>A URL fragment that points to the package resources</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>lib</term>
                    <listitem>
                        <para>A URL fragment that, when concatenated with the location variable,
                                points to the package JavaScript resources; if missing, defaults to
                                "lib".</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>main</term>
                    <listitem>
                        <para>The name of the package main resource; if missing, defaults to
                                "main".</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>packageMap</term>
                    <listitem>
                        <para>A JavaScript object that maps package names
                                referenced in the package resources to package names known to the
                                loader (the packages known to the loader are precisely the packages
                                for which a configuration exists); this will be discussed in
                            <xref linkend="nameClashes"/>.</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>urlMap</term>
                    <listitem>
                        <para>A vector of transform functions that transform computed URLs; this
                                will be discussed in <xref linkend="urlMapping"/>.</para>
                    </listitem>
                </varlistentry>
            </variablelist></para>
        <para>The conceptual "default" package has the following configuration values:</para>
        <para>
            <programlisting>
// this is ONLY conceptual; there is no real package!
name: "default", 
location: "",
lib: "",
packageMap: {},
urlMap: []
// note: it's impossible to demand the main module 
// in the default package
</programlisting>
        </para>
        <para>We now have enough information to describe how module identifiers found in dependency
            vectors are transformed into URLs:</para>
        <para>
            <orderedlist xml:id="urlCompute">
                <title>URL Computation for Module Identifiers</title>
                <listitem>
                    <para>The reference module is determined. If the URL is being computed
                            consequent a module identifier in a dependency vector in a global
                                <code>require</code> application, then there is no reference module;
                            otherwise, the URL must be being computed consequent to a module
                            identifier in a dependency vector in either a context require or a
                                <code>define</code> application, and each of these kinds of
                            applications always have an associated reference module.</para>
                </listitem>
                <listitem>
                    <para>The reference package (if any) is determined. This is simply the package
                            indicated by the reference module determined in Step 1.</para>
                </listitem>
                <listitem>
                    <para>If the module identifier is relative, then all of the relative names ("."
                            and "..") are removed by concatenating the reference module, "/../", and
                            the module identifier being resolve, and then replacing all "/./"
                            sequences with "/" and collapsing all "x/y/../z" sequences to
                            "x/z".</para>
                </listitem>
                <listitem>
                    <para>The target package and target module indicated by the
                            normalized module identifier as computed in Step 3 are determined. The
                            package name given by the module identifier is mapped by the
                                <code>packageMap</code> configuration variable for the reference
                            package (if any); if mapped successfully, then the mapped name indicates
                            the target package (I'll explain the purpose of this in <xref linkend="nameClashes"/>). If no mapping occurs, and the package name
                            is known to the loader, that name indicates the target package;
                            otherwise, the "default" target package is indicated. In the first two
                            cases (the package name was successfully mapped or was known to the
                            loader) the target module is given by the module identifier with the
                            first name removed; otherwise, the target module is given by the entire
                            module identifier. If the target module is empty after the first name is
                            removed, then the target module is set to the <code>main</code>
                            configuration variable given by the target package.</para>
                </listitem>
                <listitem>
                    <para>The computed URL is set to the <code>location</code> configuration
                        property of the target package concatenated with the <code>lib</code>
                        configuration variable of the target package concatenated with the target
                        module; concatenation inserts a "/" at each location.</para>
                </listitem>
                <listitem xml:id="urlTransform-paths">
                        <para>The <code>paths</code> mapping is applied to the computed URL; I'll
                            describe this in <xref linkend="urlMapping"/>.</para>
                    </listitem>
                <listitem xml:id="urlTransform-baseUrl">
                    <para>If the URL computed so far is not an absolute URL (that is, a URL that
                        begins with a protocol like "http:" or a slash), then the value of the
                        package-independent <varname>baseUrl</varname> configuration variable is
                        prepended to the computed URL.</para>
                </listitem>
                <listitem>
                    <para>If the URL computed so far does not include a file type, then suffix ".js"
                            is appended to the computed URL.</para>
                </listitem>
                <listitem xml:id="urlTransform-urlMap">
                        <para>The URL map for the target package (if any) and the
                            package-independent URL map (if any) are applied; I'll describe this in
                                <xref linkend="urlMapping"/>.</para>
                    </listitem>
            </orderedlist>
        </para>
        <para>Assuming no package mapping, path mapping, or URL mapping (Steps 4, 6, and 9), let's
                look at some examples. Suppose the loader was configured as
                follows:<programlisting>
baseUrl: "./",
packages: [
  {
    name: "bd",             // the backdraft package
    location: "packages/bd" // the package baseUrl
  }, {
    name: "math",
    location: "packages/math-v1",
    lib: "source",
    main: "core"
  }
]
</programlisting></para>
        <para>Here are some example transformations from module identifiers to URLs.</para>
        <para><glosslist>
            <?dbfo glosslist.as.blocks="1" ?>
            <glossentry>
                    <glossterm>bd &implies; ./packages/bd/lib/main.js</glossterm>
                <glossdef><para>The main module in the <filename>bd</filename> package. Since the <filename>bd</filename>
                                package did not specify a <varname>lib</varname> configuration
                                value, the default of "lib" is used; similarly, for the
                                    <varname>main</varname> configuration variable since this is the
                                main package.</para></glossdef>
                </glossentry>
            <glossentry>
                <glossterm>bd/widgets/stateButton &implies; ./packages/bd/lib/widgets/stateButton.js</glossterm>
                <glossdef>
                    <para>The <filename>widgets/stateButton</filename> module in the <filename>bd</filename>
                        package.</para>
                </glossdef>
            </glossentry>
            <glossentry>
                <glossterm>math &implies; ./packages/math-v1/source/core.js</glossterm>
                <glossdef>
                    <para>The main module in the <filename>math</filename> package. Notice that both
                                the <varname>lib</varname> and <varname>main</varname> configuration
                                variables where given.</para>
                </glossdef>
            </glossentry>
            <glossentry>
                <glossterm>math/singleVariableDerivation &implies;
                    ./packages/math-v1/source/singleVariableDerivation.js</glossterm>
                <glossdef>
                    <para>The <filename>singleVariableDerivation</filename> module in the
                        <filename>math</filename> package.</para>
                </glossdef>
            </glossentry>            <glossentry>
                <glossterm>app/mainPanel &implies; ./app/mainPanel.js</glossterm>
                <glossdef>
                    <para>The module <filename>app/mainPanel</filename> in the conceptual "default"
                        package.</para>
                </glossdef>
            </glossentry>
        </glosslist></para>
        </sect2>
        <sect2><title>The Redundancy of require</title>
        <para>One last observation before we conclude this section: the function
                    <code>require</code> is unnecessary. Any <code>require</code> application can be
                converted to a <code>define</code> application by inserting an unused module
                identifier. For
                example,<programlisting>
require(
  ["this/module", "that/module", "the/other/module"], 
  function(this, that, theOther) {
    // do something with this, that, and the other
  }
);
</programlisting></para>
        <para>Can be rewritten as...</para>
<programlisting>
var uniqueModuleId= "_" + (new Date).getTime();
define(
  uniqueModuleId, 
  ["this/module", "that/module", "the/other/module"], 
  function(this, that, theOther) {
    // do something with this, that, and the other
  }
);
</programlisting>
        <para>There's nothing special about the way I computed the unique module identifier; you
                could use any identifier that you know is not in use as a real module identifier.
                This is, in fact, exactly how the backdraft loader implements require.<footnote>
                    <para>Since the loader owns the module namespace, it can create a module
                        identifier that is guaranteed forever unique.</para>
                </footnote>I mention this concept not to suggest you should dispense with
                    <code>require</code> and only use <code>define</code>, but rather to help you
                build on your mental model of how the loader works.</para>
        <para>That's it for the core loader interface. There are quite a few additional features
                that are available. But even without these additional features, the API provides a
                very elegant solution for decomposing a complex program into a set of packages,
                further decomposing those packages into set of modules, and then reassembling them
                into a well-defined namespace in the run-time environment.</para>
            
       
       
        </sect2>
    </sect1>
    <sect1 xml:id="boot">  <titleabbrev>Loading the Loader</titleabbrev>
        <title>Loading and Configuring the Loader</title><para>Loading the loader into a page is trivial: simply add a script element to the page that
            references the loader resource. For
            example:<programlisting>
&lt;script src="scripts/require.js">&lt;/script>
            </programlisting></para>
        <para>The example assumes that the "require.js" resource contains the loader definition and
            resides in the "scripts" directory, and the scripts directory is in the same directory
            as the page resource.<footnote>
                <para>This is a pretty sloppy description. Where the resources actually reside is
                    the business of the http server. It is more-correct to say the http server
                    resolves the URL ./scripts/require.js to the resource that defines the
                    loader.</para>
            </footnote> Adjust the <code>src</code> attribute accordingly if this is not the
            case.</para>
        <para>When the loader definition is evaluated, it optionally computes a few configuration
            variables:</para>
        <variablelist><title>Automatic Configuration Variables</title>
            <varlistentry>
                <term>baseUrl</term>
                <listitem>
                    <para>The URL path from which the loader was loaded. In the example above, the
                        URL would be "scripts/".</para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>main</term>
                <listitem>
                    <para>The value of the <code>data-main</code> attribute (if any) on the
                            <code>baseNode</code> (see next). If <code>main</code> is provided, then
                        the loader causes <code>require([</code><emphasis role="italic">main</emphasis><code>])</code> to be executed after the loader is
                        defined. I'll discuss this more below.</para>
                </listitem>
            </varlistentry>    <varlistentry>
                <term>baseNode</term>
                <listitem>
                    <para> The DOM node of the <code>script</code> element that loaded the loader.
                        Some applications may decide to hang additional configuration off this node
                        through custom node attributes. Since the loader needs to find the node in
                        order to compute <code>baseUrl</code> as described above, it remembers the
                        node in the <code>baseNode</code> configuration variable.</para>
                </listitem>
            </varlistentry>
            
        </variablelist>
        <para>The process of computing <code>baseUrl</code>, <code>main</code>, and
                <code>baseNode</code> as described above, requires the loader sniff the document to
            find the <code>script</code> element that loaded the loader. The loader does this by
            searching for a <code>script</code> element with a <code>src</code> attribute that has a
            value that ends with the substring "require.js". If you rename the loader resource to
            something else, you'll have to adjust the sniffing code in the loader (look for the
            regular expression <code>/require\.js$/</code>). Notice that it doesn't make much sense
            to make this process configurable since if your going to provide a configuration that
            alters the sniff procedure, you might as well just include the configuration variables
            that the sniff procedure finds and dispense with the sniff procedure altogether. In
            fact, the sniff procedure is automatically disabled if <code>baseUrl</code> is provided
            in a configuration before the loader is defined (see below), and can even be removed
            from the code in a specially built version of the loader (see <xref linkend="build"/>).
            I recommend not using the sniff procedure.</para>
        <para>Once the loader is defined, the two-function load API (<code>require</code> and
                <code>define</code>) is defined in the global space. If <code>require</code> is
            defined as a function before loading the loader, the loader definition code will result
            in a no-op. In this sense, the first loader on the page wins. However, the global
            variable <code>require</code>
            <emphasis role="italic">can</emphasis> be defined as an <emphasis role="italic">object</emphasis> prior to defining the loader. In this case, <code>require</code>
            is understood to hold a configuration, which is nothing more than a JavaScript object
            with property (name, value) pairs for the various configuration variables. Here's how aa
            configuration provided before the loader is defined might
            look:<programlisting>&lt;head>
  &lt;!-- configure the loader -->
  &lt;script>]
    // require being defined in the global space
    var require= { 
      baseUrl: "./",

      main: "myApp/main",

      // packages
      [{
        name: "util1",
        location: "packages/util1"
      }]
    };
  &lt;/script>

  &lt;!-- load the loader -->
  &lt;script src="scripts/require.js">&lt;/script>
            </programlisting></para>
        <para>The <code>require</code> function (both the global and context-require varieties)
            provides yet another overload signature that allows configuring the loader after it has
            been loaded:</para>
        <funcsynopsis>
            <funcprototype>
                <funcdef>function <function>require</function></funcdef>
                <paramdef>object <parameter>configuration</parameter></paramdef>
            </funcprototype>
        </funcsynopsis>
        <para>For this signature, require returns itself to allow for each chaining.
                <code>configuration</code> is a JavaScript object containing configuration settings
            just as described above. So, you can also use the following pattern to configure the
            loader:</para>
        <programlisting>&lt;head>
  &lt;!-- load the loader -->
  &lt;script src="scripts/require.js">&lt;/script>

  &lt;!-- configure the loader -->
  &lt;script>
    require({
      baseUrl: "./",

      // more configuration properties....

    });
  &lt;/script>

 
            </programlisting>
        <para>Finally, recall that the primary signature of <code>require</code> allows you to pass
            a configuration object as the first argument. For example...</para>
        <para>
            <programlisting>
require({baseUrl:"./"}, ["myApp/myModule"], function(m) {
  // ...
});
</programlisting>
        </para>
    <para>It is possible to provide configuration values to the loader at any point in the lifetime
            of the program. The loader maintains a single, global configuration. Consequently, new
            configuration variables are additive, but providing new values for existing variables
            results in overwriting the current values of those variables. For example:</para>
        <para>
            <programlisting>require({baseUrl:"./"});
//require.baseUrl==="./"


require({baseUrl:"scripts"});
//require.baseUrl==="scripts"

require({
  packages: [{
    name: "mine",
    location: "packages/mine"
  }]
});

//the package "mine" is now known to the loader

require({
  packages: [{
    name: "yours",
    location: "packages/yours"
  }]
});

// BOTH the packages "mine" and "yours" are known
// to the loader.
</programlisting>
        </para>
        <para>The full list of configuration variables and an exhaustive example configuration is
            given in <xref linkend="configVariables"/>.</para>
    
    </sect1>
    <sect1 xml:id="nameClashes"><title>Package Name Clashes</title>

        <para>We can now turn to the problem of package name clashes, in particular how two
            different packages with the same name or two different versions of the same package can
            be loaded into the same application.</para>
        <para>Suppose two brilliant but independent programmers publish packages of utility
            functions. Because they are so brilliant neither programmer can imagine the need for yet
            another util package and therefore both decide to name their packages "util". You and I
            are just lowly developers trying to please our clients. So naturally we want to leverage
            brilliance and use one of these util packages. Unfortunately, we quickly discover that
            neither util author is quite as brilliant as they assumed and neither package contains
            all of the utils we need; instead, we need <emphasis role="italic">both</emphasis>
            packages. Now, we're in a jam because we have two different packages with the same name. </para>
        <para>Fortunately, the solution is trivial. Simply install the two util packages in two
            different directory trees and then identify the two trees as two different packages to
            the loader. For
            example:<programlisting>
baseUrl: "./",
packages: [{
    name: "util1",
    location: "packages/util1"
  }, {
    name: "util2",
    location: "packages/util2"
  }]
</programlisting></para>
        <para>You can access the packages through
            <code>require</code>:<programlisting>
require(["util1", "util2"], function(util1, util2) {
  // make client happy
});
</programlisting></para>
        <para>Or in your own module definitions through
            <code>define</code>:<programlisting>
define(["util1", "util2"], function(util1, util2) {
  // make client happy
});
</programlisting></para>
        <para>The loader resolves "util1" and "util2" into the URLs
                <filename>./packages/util1/lib/main.js</filename> and
                <filename>./packages/util2/lib/main.js</filename>, respectively. Assuming the util
            package authors followed the best practice and did not explicitly provide a
                <code>moduleId</code> argument in the define applications that create their modules,
            the loader provides the names "util1" and "util2" as derived from the module identifiers
            that caused the respective scripts to be evaluated. </para>
        <para>Next, let's see what happens to the names in the dependency vector given when a module
            from one of the packages is defined. Suppose
                <filename>./packages/util1/lib/main.js</filename> contains the following
            code:<programlisting>
// this is the definition of the first util package main module

define(["./strings", "./collections"], function(strings, collections) {
  var core= {}, p;
  for (p in strings) core[p]= strings[p];
  for (p in collections) core[p]= collections[p];
  return core;
});
</programlisting></para>
        <para>Since the reference module for the definition above is
                <filename>util</filename><emphasis role="bold">1</emphasis><filename>/main</filename>. Consequently, "./strings" &implies;
            "util1/strings" and "./collections" &implies; "util1/collections", which is exactly what
            we want.</para>
        <para>Notice what has happened. We renamed the util packages on our system by specifying but
            two lines in a configuration, yet the packages behave perfectly without any alteration
            whatsoever. The key point is this: so long as the util authors used relative module
            identifiers to refer to modules within their own packages, we, as util package
            consumers, can use two different util packages, both named "util" by their authors, in
            the same program by providing an appropriate configuration. Pretty awesome! It gets
            better.</para>
        <para>Suppose the author of the first util package used yet another package in his
            implementation. Maybe the definition of the <filename>collections</filename> module
            within the first util package looks like
            this:<programlisting>
define(["dojox/collections"], function(collections) {
  // do something with collections and return a 
  // collections API for the util package
});
</programlisting></para>
        <para>So far, so good. All the author needs to do is explain that his package depends on the
                <filename>dojox</filename> package. We, as the package consumer, simply download the
                <filename>dojox</filename> package, install it in our local package tree, inform the
            loader where to find it through the <varname>packages</varname> configuration variable
            and everything will work perfectly.</para>
        <para>Not to be outdone, the second util author also depends on the
                <filename>dojox</filename> package. But, as luck would have it, the second util
            package depends on a different version of the <filename>dojox</filename> package. The
            loader can easily accommodate two different versions of the same package just as it can
            accommodate two different libraries with the same name. The problem occurs when both of
            the util libraries refer to the same name&mdash;"dojox"&mdash;yet expect this name to
            resolve to different packages.</para>
        <para>The first thing to do is install the two different <filename>dojox</filename> packages
            just like we installed the two different util packages:</para>
        <programlisting>[{
  name: "util1",
  location: "packages/util1"
}, {
  name: "util2",
  location: "packages/util2",
}, {
  name: "dojox1",
  location: "packages/dojox-version-1-6"
}, {
  name: "dojox2",
  location: "packages/dojox-version-1-4"
}]
</programlisting>
        <para>Recall that when the first utility package demands a dojox module by writing
                <code>define(["dojox/collection"], //...</code> , the loader will resolve that name
            with respect to the reference module&mdash;which is a util1 module. So, by providing a
            map that instructs the loader how to resolve package names with respect to a particular
            package, we can solve this problem. Here's the configuration that solves the dojox name
            clash:<programlisting>[{
  name: "util1",
  location: "packages/util1",
  packageMap: {dojox:"dojox1}
}, {
  name: "util2",
  location: "packages/util2",
  packageMap: {dojox:"dojox2}
}, {
  name: "dojox1",
  location: "packages/dojox-version-1-6"
}, {
  name: "dojox2",
  location: "packages/dojox-version-1-4"
}]
</programlisting></para>
        <para linkend="urlCompute">Anytime the "dojox" package identifier is seen in a module from
            the first util package (configured as the <filename>util1</filename> package), the
            loader will inspect the <code>packageMap</code> configuration variable of the
                <filename>util1</filename> package and see that "dojox" maps to "dojox1". This is
            part of Step 4 in <xref linkend="urlCompute"/>. Similarly, the loader will resolve the
            package identifier "dojox" in the second util package to "dojox2". From there, the
            standard URL resolution algorithm proceeds as usual.</para>
        </sect1>
    <sect1 xml:id="urlMapping">
        <title>URL and Path Mapping</title>
        <para>Back in <xref linkend="urlCompute"/> when I described how a module identifier is
            transformed into a URL, I mentioned that the computed URL could be submitted to a
            further transform in Step 9 of the process. That further transform is caused by the
                <varname>urlMap</varname> configuration variable. Each package may specify a
                <varname>urlMap</varname> and a single, package-independent <code>urlMap</code>
            configuration variable may also be provided.</para>
        <para><varname>urlMap</varname> is a vector of functions that take a URL and optionally
            transform that URL into other URL. If a particular function is not interested in a
            particular URL, it simple returns falsy to indicate as such. Once the loader transforms
            a module identifier to a URL, it submits the computed URL to each function in the URL
            map for the package (if any) implied by the reference module and then to the
            package-independent URL map (if any). The first function that returns a value wins and
            that ends of the transformation. Let's look at an example.</para>
        <para>Suppose all HTML templates for the package "acmeWidgets" are stored in the
                <filename>templates</filename> directory rather than the <filename>lib</filename>
            directory, and further all template have the file type ".html". So, for example, when an
            acmeWidgets module specifies the module identifier "acmeWidgets/templates/radioButton",
            it is intending on pointing to
                <filename>acmeWidgets/templates/radioButton.html</filename>, not
                <filename>acmeWidgets</filename><emphasis role="bold">/lib</emphasis><filename>/templates/radioButton</filename><emphasis role="bold">.js</emphasis>. This could be accomplished with the following acmeWidgets package
            configuration:<programlisting>
{
  name: "acmeWidgets",
  location: "packages/acmeWidgets",
  urlMap: [
    function(name) {
      match= name.match(/^(.+)\/lib\/templates\/(.+)(\.js)$/);
      if (match) {
        return match[1] + "/templates/" + match[2] + ".html"
      }
      return 0;
    }
  ]
}
  </programlisting></para>
        <para>Remember, the URL map will be traversed after the standard module identifier to URL
            transform has taken place. For example, the standard transform will take
                <filename>acmeWidgets/templates/radioButton</filename> to <emphasis role="italic">baseUrl</emphasis><filename>/packages/acmeWidgets/lib/templates/radioButton.js</filename>.
            The urlMap provided above simply transforms "lib/templates" into "templates" and
            replaces the "js" suffix with "html".</para>
        <para>Often, code that demands a module that is known to not be JavaScript will explicitly
            include the file type in the module identifier, for example
            "acmeWidgets/templates/radioButton.html". In the case, the resulting transform is
            simplified:</para>
        <programlisting>
  function(name) {
    match= name.match(/^(.+)\/lib\/templates\/(.+)/);
    if (match) {
      return match[1] + "/templates/" + match[2];      }
    return 0;
  }
  </programlisting>
        <para>This is an example of a transform that finds a constant string (that is, the string
            doesn't depend on <code>name</code>) and replaces it with another constant string. In
            fact, this kind of transform is so common, that the backdraft loader provides a shortcut
            method of specifying it: provide a (<code>pattern</code>, <code>replacement</code>)
            ordered pair, indicating that <code>pattern</code> (a regular expression), if found in
            name, should be replaced with <code>replacement</code> (a string). The URL map given
            above could then be
            rewritten:<programlisting>
urlMap: [
    [/\/lib\/package\//, "templates"]
]
</programlisting></para>
        <para>The backdraft loader also includes the so-called "paths" map that's available in other
            loaders. A paths map maps a set of path prefixes to replacement strings. For example, a
                <varname>paths</varname> configuration variable set like
            this...<programlisting>
paths: {
  "myPackage/some/path":"some/other/path"
}
</programlisting></para>
        <para linkend="urlCompute">...would map "myPackage/some/path/myModule" to
            "some/other/path/myModule". The backdraft loader honors any paths configuration and
            applies such configuration in Step 6 of <xref linkend="urlCompute"/>. Of course the same
            effect could be achieved through the urlMap feature.</para>
        <para>In my work, I've found the paths feature lacking. It doesn't allow prioritization and
            only works to fix a limited set of transforms at the beginning of the path. One of the
            best examples of how the urlMap feature can be used to great advantage is in the
            dojo-sie project where I map some dojo modules to the v1.x tree and others to the v2.x
            tree. Of course this is a fairly unusual circumstance. Indeed, in most cases you ought
            not to need even a paths transform, let alone a prioritized, generalized transform like
            the urlMap. Nevertheless, when you need it, other solutions fall short.</para>
        <para>Finally, the entire module identifier to URL transform process is available to client
            code through the method <code>require.toUrl</code>:</para>
        <funcsynopsis>
            <funcprototype>
                <funcdef>string <function>require.toUrl</function></funcdef>
                <paramdef>string <parameter>name</parameter></paramdef>
            </funcprototype>
        </funcsynopsis>

        <para><code>require.toUrl</code> submits the name argument to the module identifier to URL
            transform and returns the result. The <code>toUrl</code> method is provided off both the
            global require function and context requires created with respect to a reference module.
            Naturally, the latter resolves names with respect to the reference module that created
            the context require. </para>
    </sect1>
    <sect1 xml:id="plugins"><title>Plugins</title><para>The loader loads JavaScript resources. But there are other kinds of resources, for example
            templates and internationalization ("i18n") bundles that an application may need to
            load. Your particular application may define yet other specialized kinds of loadable
            resources of which the loader knows nothing. In order to accommodate this problem, the
            loader provides an extension point termed a "plugin" that allows a module identifier to
            be specified that delegates the loading of that module to additional machinery that is
            "plugged in" to the loader.</para>
        <para>Here's how it works. When a module identifier contains an exclamation point, the
            loader splits the name into two module identifiers at the "!". The module identifier to
            the left of the "!" gives the name of a plugin (itself a module); the identifier to the
            right gives the identifier to delegate to the that plugin for loading. The loader loads
            the plugin (once) which must return a value that is an object that contains the function
                <code>load</code>:</para>
        <funcsynopsis>
            <funcprototype>
                <funcdef>void <function>load</function></funcdef>
                <paramdef>function <parameter>contextRequire</parameter></paramdef>
                <paramdef>string <parameter>moduleId</parameter></paramdef>
                <paramdef>function <parameter>callback</parameter></paramdef>
            </funcprototype>
        </funcsynopsis>
  
        <para>Once the plugin has been loaded, the loader sends the module identifier to the right
            of the "!" to the <code>load</code> function:
            <itemizedlist>
                <listitem>
                    <para>A context-require is manufactured with respect to the reference module
                        that is demanding the plugin module and is passed in the
                            <code>contextRequire</code> argument.</para>
                </listitem>
                <listitem>
                    <para>The module identifier to the right of the "!" is passed in the
                            <code>moduleId</code> argument.</para>
                </listitem>
                <listitem>
                    <para>A a single-argument function that receives the value that the plugin
                        computes for the module <code>moduleId</code> is manufactured and passed in
                        the <code>callback</code> argument.</para>
                </listitem>
            </itemizedlist>
        </para>
        <para>The plugin "loads/computes" (whatever that means to the plugin) the module implied by
            the <code>moduleId</code> argument and reports the value of that module to the loader
            through the <code>callback</code> function. Like all module values, the loader remembers
            the value of the module, and future demands for the same module do not result in calling
            the plugin <code>load</code> function. This system is incredibly elegant and powerful.<footnote>
                <para>The original plugin idea in the context of the loader was invented by James
                    Burke and this particular implementation was proposed by Kris Zyp.</para>
            </footnote>Here is an example of loading some raw text with the <code>text</code>
            plugin:</para>
        <para>
            <programlisting>
require(["text!myPackage/templates/myModule"], function(template) {
  // template is a string loaded from the resource implied by 
  // myPackage/myModuole/myTemplage
});
</programlisting>
        </para>
        <para>Here is the text plugin included with
            dojo-sie:<programlisting>define(["dojo"], function(dojo) {
  return {
    load: function(require, id, loaded) {
      dojo.xhrGet({
        url: require.toUrl(id),
        load: function(text) {
          loaded(text);
        }
      });
   }
  };
})</programlisting></para>
        <para>To my eye, this is just about as beautiful as code can get!</para>
        <para>Notice that plugins are the primary consumers of the <code>require.toUrl</code> API.
            In the example above, the demand for "text!myPackage/templates/myModule" caused the
            loader to request the text plugin to load "myPackage/templates/myModule". It is likely
            that a URL map entry was also specified in the configuration so that
                <code>require.toUrl("myPackage/templates/myModule")</code> returns a URL something
            like "./packages/myPackage/templates/myModule.html".</para></sect1>

    <sect1><title>DOM Content Loaded Detection</title><para>The backdraft loader includes machinery to detect the DOM content loaded condition as well as
            connection machinery to register and then fire callbacks upon detection of this
            condition. The method <code>require.addOnLoad</code> registers callbacks:</para>
        <funcsynopsis>
            <funcprototype>
                <funcdef>void <function>addOnLoad</function></funcdef>
                <paramdef>[optional]object <parameter>context</parameter></paramdef>
                <paramdef>function or string <parameter>callback</parameter></paramdef>
            </funcprototype>
        </funcsynopsis>
      
        
    <para><code>addOnLoad</code> composes <code>context</code> and <code>callback</code> into a
            function application:<itemizedlist>
                <listitem>
                    <para>if context is provided and callback is a string, then callback is composed
                        as <code>context[callback].call(context)</code></para>
                </listitem>
                <listitem>
                    <para>if context is provided and callback is a function, the callback is
                        composed as <code>callback.call(context)</code></para>
                </listitem>
                <listitem>
                    <para>if context is not provided, the callback is compose as
                            <code>callback.call(null)</code></para>
                </listitem>
            </itemizedlist></para>
        <para>When a callback is provided to <code>addOnLoad</code>, if the DOM content loaded
            condition has already been achieved, the callback is immediately executed; otherwise,
            the loader queues the callback and then runs the queue of callbacks when the DOM content
            loaded condition is finally detected. The loader configuration variable
                <code>pageLoaded</code> indicates whether or not the DOM content loaded condition
            has been achieved.<footnote><para>If your application knows that the condition has been achieved (if, for example, your
                    application loads itself consequent to the page load event), you can explicitly
                    set <code>pageLoaded</code> to true in the configuration. On some browsers, DOM
                    content loaded detection is sometimes not predictable, and this technique
                    purports to avoid the problem. Then again, if you know that the page is loaded,
                    you shouldn't need to use this machinery. This feature is included primarily for
                    compatibility with other loaders, and I neither see its value nor recommend its
                    use.</para></footnote></para>
        <para>This functionality is often used in applications that use a synchronous loader, for
            example applications constructed with the Dojo v1.x synchronous loader. However, it is
            much less useful with an asynchronous loader such as the backdraft loader. To understand
            why, consider the typical application pattern you'll see in a HTML document:</para>
        <para>
            <orderedlist>
                <listitem>
                    <para>Include a loader; this goes in the <code>head</code> element.</para>
                </listitem>
                <listitem>
                    <para>Instruct the loader to load the application source code; this also goes in
                        the <code>head</code> element.</para>
                </listitem>
                <listitem>
                    <para>Include the html <code>body</code> element and its contents.</para>
                </listitem>
            </orderedlist>
        </para>
        <para>With a synchronous loader, Steps 1 and 2 are accomplished synchronously. The code is
            often downloaded by using synchronous XHR. On the other hand, the asynchronous loader
            never blocks on synchronous XHR calls. Consequently, browsers typically load the body
            element much quicker&mdash;well before the application code is downloaded. To see this
            effect, observe the difference in behavior of nontrivial dijit programs using either the
            dojo v1.x synchronous loader compared to the backdraft loader. The dojo-sie project has
            posted a few examples at <link xlink:href="http://dojo-sie.org/demos.html">http://dojo-sie.org/demos.html</link>.</para>
        <para>I find executing code dependent on the DOM content loaded status to be of little
            value. If the application is trivial, then the page should load fast enough that the
            difference between the page load event and the DOM content loaded status is negligible.
            In this case, a listener can be connected to the page load event like any normal event,
            obviating the need for the specialized and sometimes-flaky DOM content loaded machinery.
            If, on the other hand, the application includes so much code that it causes a noticeable
            delay loading, then it should be restructured so that a tiny, self-contained pacifier is
            included in the initial HTML resource and the real application loads while the pacifier
            is occupying the user. See <link xlink:href="http://bdframework.org/pacify.html"
                >http://bdframework.org/pacify.html</link> for an example of this pattern. This
            said, DOM content loaded machinery is included if you want to use it.</para>
    </sect1>  
    <sect1 xml:id="errorReporting"><title>Error Detection and Recovery</title><para>There are three places the loader can detect errors:<orderedlist>
                <listitem>
                    <para>When a module identifier resolves to a URL that causes a download or
                        evaluation error.</para>
                </listitem>
                <listitem>
                    <para>When a module factory causes an exception.</para>
                </listitem>
                <listitem>
                    <para>When an <code>onPageLoad</code> callback causes an exception.</para>
                </listitem>
            </orderedlist></para>
        <para>Remember, the loader's job is to load chunks of JavaScript code that are expected to
            exist and behave. If you need to load things that may not exist and/or may not behave,
            and you have some plan for how to handle non-existing/misbehaving scripts, then the
            solution is to write a plugin to handle such resources. Over the years I've seen many
            elaborate error recovery systems that purport to take over and fix things when code
            fails to execute as expected. I always find it incredible that programmers claim that
            they can build systems that recognize, catch, and repair code that doesn't work as
            expected. This is a non sequitur: the claim asserts the ability to build faultless
            systems that have faults.<footnote>
                <para>It's another matter entirely to design a fault-tolerant system to fix things
                    when expected faults occur.</para>
            </footnote></para>
        <para>In fact, usually the best strategy is to catch the defect at the earliest possible
            point in the execution flow, report all that's know about the defect, disable the
            particular section of the program that failed or terminate the entire program. Often the
            worst thing to do is muddle on as if nothing happened. Indeed, sometimes the user won't
            recognize the defect immediately, and then report a failure that occurs later in
            execution that becomes much harder to explain because the root cause was ignored.<footnote>
                <para>Or, even worse, never know the program was misbehaving and make wrong
                    decisions based on wrong program output.</para>
            </footnote></para>
        <para>With this in mind, the loader provides the <code>onError</code> method on the global
                <code>require</code> function:</para>
        <para>
            <funcsynopsis xml:id="onError">
                <funcprototype>
                    <funcdef>any <function>require.onError</function></funcdef>
                    <paramdef>string <parameter>messageId</parameter></paramdef>
                    <paramdef>array of any <parameter>args</parameter></paramdef>
                </funcprototype>
            </funcsynopsis>
        </para>
        <para><code>onError</code> maintains the property <code>require.onError.listeners</code>,
            which is an array of callback functions. <code>require.onError</code> sends
                <code>messageId</code> and <code>args</code> to the debug console and applies
                (<code>messageId</code>, <code>args</code>) to all callbacks in
                <code>require.onError.listeners</code>. As the callbacks are being applied,
                <code>onError</code> remembers the result of the first callback that returns a
            truthy value (if any). If such a result was detected, <code>onError</code> returns this
            result; otherwise, onError returns <code>0</code>.</para>
        <para>The loader publishes the following three <code>messageId</code> values with associated
            arguments upon error detection.<orderedlist>
                <listitem xml:id="timeoutError">
                    <para>"loader/timeout", when one or more demanded resources fail to arrive
                        within the time limit prescribed by the configuration variable
                            <code>timeout</code>. <code>args</code> contains an object that lists
                        the modules that failed to arrive.</para>
                </listitem>
                <listitem>
                    <para>"loader/exec", when a module factory causes an exception.
                            <code>args</code> contains the following values:<orderedlist>
                            <listitem>
                                <para>the exception object that was thrown</para>
                            </listitem>
                            <listitem>
                                <para>the fully-resolved module identifier of the module factory
                                    that threw the exception</para>
                            </listitem>
                            <listitem>
                                <para>the first argument sent to the factory</para>
                            </listitem>
                            <listitem>
                                <para>the second argument sent to the factory </para>
                            </listitem>
                            <listitem>
                                <para>etc.</para>
                            </listitem>
                        </orderedlist>If a truthy value is returned by one of the callbacks, then
                        the value of the module that threw the exception is set to this value;
                        otherwise, the value of the module is set to the exception object that was
                        caught.</para>
                </listitem>
                <listitem>
                    <para>"loader/onLoad", when an <code>onLoad</code> callback causes an exception.
                            <code>args</code> includes the exception object that was thrown.</para>
                </listitem>
            </orderedlist></para>
        <para>Clients may connect to onError by pushing a callback into
                <code>require.onError.listeners</code>. Clients may also use
                <code>require.onError</code> to publish their own error detection; the loader
            reserves <code>messageIds</code> that start with "loader/".</para></sect1>  
    <sect1 xml:id="tracing"><title>Tracing</title><para>Because <code>require</code> and <code>define</code> are designed to operate asynchronously,
            debugging strange load problems can be frustrating. Also beware that adding breakpoints
            will often change the execution flow of an asynchronous process. To help this situation,
            the loader includes tracing machinery that sends messages to the console and then
            optionally uses that machinery to report loader events.</para>
        <para>The loader provides the <code>trace</code> method on the global <code>require</code>
            function:</para>
        <funcsynopsis xml:id="trace">
            <funcprototype>
                <funcdef>void <function>require.trace</function></funcdef>
                <paramdef>string <parameter>groupId</parameter></paramdef>
                <paramdef>array of any <parameter>args</parameter></paramdef>
            </funcprototype>
        </funcsynopsis>
        <para><code>require.trace</code>  calls <code>console.log(groupId, args[0], args[1],
                ...)</code> if and only if <code>req.traceSet[groupId]</code> is truthy.</para>
        <para>The loader provides the following <code>require.traceSet</code> group identifiers with
            associated semantics:
            <itemizedlist>
                <listitem>
                    <para>"loader-define": reports when the loader <code>define</code> function was
                        applied. </para>
                </listitem>
                <listitem>
                    <para>"loader-runFactory": reports just before a module factory is
                        executed</para>
                </listitem>
                <listitem>
                    <para>"loader-execModule": reports just before the dependencies for a module are
                        evaluated</para>
                </listitem>
                <listitem>
                    <para>"loader-execModule-out": reports just after all dependencies have been
                        evaluated and the factory has ben executed.</para>
                </listitem>
                <listitem>
                    <para>"loader-defineModule": reports when the arguments for a previous
                            <code>define</code> application are about to be processed by the
                        loader.</para>
                </listitem>
            </itemizedlist>
        </para>
        <para>These can be turned on by adding an initial value of <code>traceSet</code> to the
            configuration. For example,</para>
        <para>
            <programlisting>
var require= {
  traceSet: {
    "loader-define":1,
    "loader-defineModule":1,
    "loader-runFactory":1,
    "loader-execModule":1,
    "loader-execModule-out":1
  },
  // the rest of the configuration...
</programlisting>
        </para>
    <para>This property can also be adjusted during program execution.</para>
        <para>Debugging asynchronous load problems can be tricky; see
            <link xlink:href="http://bdframework.org/docs/debugAsyncLoad/debugAsyncLoad.html">Debugging Asynchronous Loading Problems</link> for more advice.</para></sect1>
    <sect1><title>has.js</title><para>The backdraft loader is highly configurable. It uses the <link xlink:href="https://github.com/phiggins42/has.js">has.js</link> API to control
            certain aspects of its configuration. The has.js client-side API consists of a the
            single function has:</para>
        <funcsynopsis>
            <funcprototype>
                <funcdef>boolean <function>has</function></funcdef>
                <paramdef>string <parameter>feature</parameter></paramdef>
            </funcprototype>
        </funcsynopsis>
        <para><code>has</code> returns true if <code>feature</code> exists, false otherwise. The
            backdraft loader blocks several sections of code with <code>has</code> expressions, for
            example,</para>
        <para>
            <programlisting>

  if (has("loader-timeout")) {
    // loader code to implement timeout detection goes here
  } else {
    // loader code to operate without timeout detection goes here
  }
</programlisting>
        </para>
    <para>Most of the <code>has</code> configuration options are intended to be used with a build
            tool that strips unused parts of the loader for a released system. However, one of the
            nice ideas behind <code>has</code> is the ability to turn features on and off during
            developement/testing without having to rebuild the application.</para>
        <para>The backdraft loader will use an existing <code>has</code> implementation if it has
            been defined on the global variable <code>has</code> prior to defining the loader. On
            the other hand, if no such has is available, then the loader will define a trivial has
            implementation that looks like this:</para>
        <para>
            <programlisting>
has= function(name) { 
  return require.hasMap[name]; 
};
</programlisting>
        </para>
        <para><code>has</code> features/values may be added/edited in <code>require.hasMap</code>
            through the loader configuration variable <code>hasValues</code>. For example to add
            "myFeature" that is has the value of true, provide a configuration like this:</para>
        <para><programlisting>
require({
  hasValues: {
    myFeature:true
  }
});
</programlisting>Providing/editing
            has feature values through the configuration machinery will not delete existing has
            feature values.</para>
        <para>If you load a module that provides an alternate <code>has</code> implementation, then
            you may find it desirable to mix the <code>has</code> values known to the loader into
            the alternate <code>has</code> implementation. If the <code>has</code> feature
            "loader-pushHas" is true, then the loader will leverage the <code>has</code> API's
                <code>add</code> function to publish all <code>has</code> feature values known to
            the loader to the alternate <code>has</code> when the alternate <code>has</code>'s
            factory is executed. </para>
       
        <para>The standard development loader includes the has features listed below;
            many&mdash;including the entire loader <code>has</code> implementation&mdash;can be
            removed in built versions of the loader depending upon your requirements. </para><para><table frame="all">
                <title/>
                <tgroup cols="2">
                    <colspec colname="c1" colnum="1" colwidth="1.0*"/>
                    <colspec colname="c2" colnum="2" colwidth="1.53*"/>
                    <thead>
                        <row>
                            <entry>feature</entry>
                            <entry>semantics</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>loader-sniffApi</entry>
                            <entry><para>The loader define machinery that will attempt to find the script element that included the
                                    loader definition, and, if found, the loader will calculate the
                                        <code>baseUrl</code> configuration variable from the
                                        <code>src</code> attribute, check for and read a
                                        <code>data-main</code> attribute, and set the value of the
                                        <code>require.baseNode</code> to this DOM node; this
                                    machinery is deleted otherwise. See <xref linkend="boot"
                                    />.</para></entry>
                        </row>
                        <row>
                            <entry>"loader-traceApi"</entry>
                            <entry><para>The loader will define the <code>require.trace</code> method and make the trace groupIds
                                    listed in <xref linkend="tracing"/>available; this machinery is
                                    deleted otherwise. See <xref linkend="tracing"/></para></entry>
                        </row>
                        <row>
                            <entry>"loader-errorApi"</entry>
                            <entry><para>The loader will define the <code>require.onError</code> method
                                and make the error reporting listed in <xref linkend="errorReporting"/> available; this
                                machinery is deleted otherwise.</para></entry>
                        </row>
                        <row>
                            <entry>"loader-injectApi"</entry>
                            <entry>The loader will define machinery to inject modules as given by
                                URLs implied by module identifiers into the execution environment;
                                this machinery is deleted otherwise.</entry>
                        </row>
                        <row>
                            <entry>"loader-timeoutApi"</entry>
                            <entry><para>The loader will define machinery to monitor the elapsed time
                                since the last resource was requested and if/when this time exceeds
                                the configuration variable <code>timeout</code>, publish an error as
                                described in <xref linkend="timeoutError"/>; this machinery is deleted otherwise.</para></entry>
                        </row>
                        <row>
                            <entry>"loader-catchApi"</entry>
                            <entry><para>The loader will surround each module factory execution and each
                                    <code>onLoad</code> callback with a try-catch block and
                                exceptions will be reported as described in <xref linkend="errorReporting"/>; otherwise, the loader
                                does not catch any exceptions.</para></entry>
                        </row>
                        <row>
                            <entry>"loader-pageLoadApi"</entry>
                            <entry>The loader will detect the DOM content loaded event and fire the
                                onLoad queue; otherwise the detection machinery is deleted and
                                callbacks applied to <code>addOnLoad</code> are fired
                                immediately.</entry>
                        </row>
                        <row>
                            <entry>"loader-requirejsApi"</entry>
                            <entry><para>The loader will cause the following definitions in order to maintain more-complete requirejs compatibility:<itemizedlist>
                                        <listitem>
                                            <para><code>require.nameToUrl</code> ===
                                                  <code>require.toUrl</code></para>
                                        </listitem>
                                        <listitem>
                                            <para>the <code>ready</code> configuration variable will
                                                be considered equal to the backdraft
                                                  <code>onLoad</code> configuration variable</para>
                                        </listitem>
                                        <listitem>
                                            <para><code>require.ready</code> ===
                                                  <code>require.addOnLoad</code></para>
                                        </listitem>
                                        <listitem>
                                            <para><code>require.def</code> ===
                                                <code>define</code></para>
                                        </listitem>
                                    </itemizedlist>These aliases are not defined otherwise.</para></entry>
                        </row>
                        
                        <row>
                            <entry>"loader-undefApi"</entry>
                            <entry>The loader will provide the method <code>undef</code> on the
                                    <code>require</code> function which causes a module to be
                                discarded as if it was never defined; this machinery is deleted
                                otherwise.</entry>
                        </row>
                        <row>
                            <entry>"loader-libApi"</entry>
                            <entry>The loader will publish its internal functions
                                    <code>isEmpty</code>, <code>isFunction</code>,
                                    <code>isString</code>, <code>isArray</code>,
                                    <code>forEach</code>, <code>setIns</code>, <code>setDel</code>,
                                    <code>mix</code>, <code>uid</code>, <code>on</code>, and
                                    <code>injectScript</code> as methods of
                                <code>require</code>.</entry>
                        </row>
                        <row>
                            <entry/>
                        </row>
                        <row>
                            <entry>"nativeXhr"</entry>
                            <entry>Indicates the environment includes a native XHR implementation;
                                    <code>has</code> standard feature detect.</entry>
                        </row>
                        <row>
                            <entry>"loader-amdFactoryScan"</entry>
                            <entry>The loader will implement the CommonJS factory scan described in
                                    <link
                                    xlink:href="http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition"
                                    >Modules/AsynchronousDefinition</link> so long as the
                                environment provides a working <code>toString</code> method on
                                function objects.</entry>
                        </row>
                        <row>
                            <entry>"function-toString"</entry>
                            <entry>Indicates the environment includes a working
                                    <code>toString</code> method on function objects;
                                    <code>has</code> standard feature detect.</entry>
                        </row>
                        <row>
                            <entry>"dom"</entry>
                            <entry>Indicates the environment include the DOM; <code>has</code>
                                standard feature detect.</entry>
                        </row>
                        <row>
                            <entry>"dom-addEventListener"</entry>
                            <entry>Indicates the environment includes W3C
                                    <code>addEventListener</code> method on DOM nodes.</entry>
                        </row>
                        <row>
                            <entry>"console"</entry>
                            <entry>Indicates the environment includes a debug console.</entry>
                        </row>
                        <row>
                            <entry>"console-log-apply"</entry>
                            <entry>Indicates the environment allows calling the <code>apply</code>
                                method on the debug console.</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            </para></sect1>
    
   
    <sect1 xml:id="build"><title>Building Release Systems</title><para>Let's take a step back and think about the loader from a very high-level perspective. What is
            its <emphasis role="italic">real</emphasis> purpose?</para>
        <para>I believe the loader exists to allow programmers to divide a big program up into
            packages and further divide those packages into modules, and then later reassemble it
            all in a controlled manner&mdash;both in terms of namespace and dependency
            management&mdash;in the run-time environment. During development, you want to keep
            things divided because debugging a 10K line script is a bad thing.</para>
        <para>Notice that once development is complete, the loader loses much of its value. In fact,
            if you could take a snapshot of a freshly loaded, complete application (assuming no
            dynamic loading after the program starts running), you could just zip up this snap shot
            and distribute it as your application in a single file. This would have several
            advantages:
            <itemizedlist>
                <listitem>
                    <para>The latency inherit in multiple http transactions would be essentially be
                        zero (one transaction).</para>
                </listitem>
                <listitem>
                    <para>The single script would be compressed more effectively than many smaller
                        scripts.</para>
                </listitem>
                <listitem>
                    <para>There would be zero synchronous inject events (for example, module A
                        demands module B which demands module C); everything arrives at once.</para>
                </listitem>
            </itemizedlist>
        </para>
        <para>Depending upon how the module resources where packaged in the single file, most of the
            loader would be completely unnecessary, and could therefore be discarded.</para>
        <para>The backdraft loader includes a couple of features that allow these kinds of
            optimizations. First, the configuration variable <code>cache</code> contains a map from
            fully resolved module name (a string) to a function that causes the same code to execute
            that would have executed if the given module had been resolved to a URL and loaded. This
            allows providing a configuration that may include many scripts in a single file. Before
            the loader injects a module, it checks to see of it exists in the cache, and if so,
            simply executes the injection function; otherwise it operates normally and resolves the
            module to a URL and injects the given URL.</para>
        <para>You can take this a step further if all of the modules for a particular application
            are contained in the cache. In this case, you can build the loader with the
                <code>has</code> feature "loader-injectApi" set to false. To get the absolutely
            smallest loader, build the loader without the sniff, trace, timeout, buildTools,
            requirejs, and undef APIs and the loader-amdFactoryScan. Depending upon your design, you
            may be able to also remove the pageLoad and lib APIs. Generally, I recommend keeping the
            catch and error APIs. This loader will be very small indeed, coming in at a mere 1.7K
            bytes!</para>
        <para>ALTOVISO will be releasing a build tool in the winter of 2010. But a simple build tool
            is trivial to construct: simply wrap each module resource in a function and assign it to
            the <code>cache</code> property name <code>"</code><emphasis role="italic">packageId</emphasis><code>*</code><emphasis role="italic">moduleId</emphasis><code>"</code>as given by the fully resolved module.</para></sect1>
    <sect1 xml:id="configVariables">  <titleabbrev>Configuration Variables</titleabbrev>
        <title>Configuration Variables Reference</title>
        
        <para>
            <table frame="all">
                <title>Configuration Variables</title>
                <tgroup cols="2">
                    <colspec colname="c1" colnum="1" colwidth="1.0*"/>
                    <colspec colname="c2" colnum="2" colwidth="4.0*"/>
                    <thead>
                        <row>
                            <entry>feature</entry>
                            <entry>semantics</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row><entry>Basic, Package-Independent Configuration</entry></row>
                        <row><entry>timeout</entry><entry>(integer, <code>0</code>) The number of milliseconds to wait for all requested resources to
                                arrive before signalling an error by require.onError (see <xref linkend="timeoutError"/>); zero indicates never signal an
                                error.</entry></row>
                        <row><entry>baseUrl</entry><entry>(string) The value to prepend to computed URLs that are not absolute (see <xref
                                    linkend="urlTransform-baseUrl"/>).</entry></row>
                        <row><entry>paths</entry><entry>(map:pathPrefix --> replacement[string]) A map, given as a JavaScript object, that maps a
                                prefix to a computed URL to a replacement prefix for that computed
                                URL (see <xref linkend="urlTransform-paths"/>.</entry></row>
                        <row><entry>urlMap</entry><entry>(array of function(string) --> [string | falsy]) A list of functions that take a computed URL
                                and transform that URL into another URL or falsy (see <xref
                                    linkend="urlTransform-urlMap"/></entry></row>
                        
                        <row><entry>Package Configuration</entry></row>
                        <row><entry>packagePaths</entry><entry><para>(map:path --> array of packageId[string]) A map, given as a JavaScript object, that maps a
                                    package location to a set of packages that ar rooted at that
                                    location. For example...</para>
                            <programlisting>
packagePaths: {
  packages: ["myPackage", yourPackage"],
  extPackages: ["dojo"]
}
                            </programlisting>
                        <para>...is equivalent to ...</para>
                            <programlisting>
packages: [{
  name: "myPackage",
  location: "packages/myPackage"
}, {
  name: "yourPackage",
  location: "packages/yourPackage"
}, {
  name: "dojo",
  location: "extPackages/dojo"
}]
                            </programlisting></entry></row>
                        <row><entry>packages</entry><entry>(array of packageConfigurationObject) An array or package configuration objects. Each object
                                is a JavaScript object with the properties <code>name</code>,
                                    <code>location</code>, <code>lib</code>, <code>main</code> ,
                                    <code>urlMap</code>, and <code>packageMap</code>; the
                                    <code>lib</code>, <code>main</code>, <code>urpMap</code>, and
                                    <code>packageMap</code> properties are optional.
                                    <code>lib</code>, if missing, defaults to <code>"lib"</code>.
                                    <code>main</code>, if missing, defaults to <code>"main"</code>.
                                    <code>urlMap</code>, if missing, defaults to <code>[]</code>.
                                    <code>packageMap</code>, if missing, defaults to
                                <code>{}</code>.</entry></row>
                        
                        <row><entry>has.js Configuration</entry></row>
                        <row><entry>has</entry><entry>The <code>has.js</code>
                                <code>has</code> function. The loader definition prefers this
                                configuration variable to any existing global <code>has</code>
                                function; and it prefers an existing global <code>has</code>
                                function to  its own, trivial has implementation.</entry></row>
                        <row><entry>hasValues</entry><entry>(map:featureName --> boolean) A map, given as a JavaScript object, that maps has.js features
                                to values for use with the loader's has implementation. This
                                configuration variable is not used when an external has.js
                                implementation is provided.</entry></row>
                        <row><entry>useLoaderHas</entry><entry>(boolean) If true the module has is set to the <filename>has</filename> implementation known
                                to the loader.</entry></row>
                        
                        <row><entry>Build Configuration</entry></row>
                        <row><entry>cache</entry><entry>(map:fullyQualifiedModuleId-->function() --> void) A map from a fully qualified module
                                identifier to a function that, when executed, has the same effect as
                                if the implied module was loaded. The fully qualified module
                                identifier is of the form <code>"</code><emphasis role="italic"
                                    >packageId</emphasis><code>*</code><emphasis role="italic"
                                    >moduleId</emphasis><code>"</code>, where packageId is a package
                                identifier known to the loader (because a package configuration with
                                the given name exists), or the empty string, denoting the conceptual
                                default package.</entry></row>
                        <row><entry>modules</entry><entry>(map:fullyQulaifiedModuleId --> moduleInfo) A map from fully qualified module identifier to
                                module information that is maintained by the loader. Module
                                information is a JavaScript object, but is subject to change without
                                notice. This structure can be useful to watch when debugging loading
                                problems. It should not be edited by client processes.</entry></row>
                        <row><entry>execQ</entry><entry>(array of moduleInfo) The list of modules that are waiting to run their factories. This structure can be useful to watch when debugging loading problems. It should not be edited by client processes.</entry></row>
                        
                        <row><entry>Tracing Configuration</entry></row>
                        <row><entry>trace</entry><entry>(function, see <xref linkend="trace"/> for prototype) The loader tracing function; may be
                                replaced configuration. See <xref linkend="tracing"/>.</entry></row>
                        <row><entry>traceSet</entry><entry>(map:traceGroupId --> boolean) A map, given as a JavaScript object, that indicates which
                                trace groups should emmit tracing output.</entry></row>
                        
                        <row><entry>Error Publishing Configuration</entry></row>
                        <row><entry>onError</entry><entry>(function, see <xref linkend="onError"/> for prototype)The loader error reporting function;
                                may be replaced by configuration. See <xref linkend="errorReporting"
                                /></entry></row>
                        
                        <row><entry>DOM Content Loaded Configuration</entry></row>
                        <row><entry>pageLoaded</entry><entry>(boolean) True if DOM content loaded is true; false otherwise.</entry></row>
                        <row><entry>skipIeDomLoaded</entry><entry>(boolean) True if an only if the Internet Explorer DOM content loaded detection algorithm
                                should not be executed.</entry></row>
                        <row><entry>ready</entry><entry>(function) Function to execute upon detection of DOM content loaded; synonym for
                                    <code>addOnLoad</code>.</entry></row>
                        <row><entry>addOnLoad</entry><entry>(function) Function to execute upon detection of DOM content loaded.</entry></row>
                        
                        <row><entry>Constant Configuration Calculated by the Loader</entry></row>
                        <row><entry>host</entry><entry><code>"browser"</code> if and only if loader is executing in the browser environment.</entry></row>
                        <row><entry>isBrowser</entry><entry><code>true</code> if and only if the loader is executing in the browser environment.</entry></row>
                        <row><entry>baseNode</entry><entry>(DOM node) The script element that included the loader definition.</entry></row>
                        
                        
                    </tbody>
                </tgroup>
            </table>
        </para>
    </sect1>
 
</article>
